<!DOCTYPE html>
<html>
<head>
<!-- Load the Paper.js library -->
<script type="text/javascript" src="paper-full.js"></script>

<script type="text/javascript" src="config.js"></script>
<script type="text/javascript" src="declicam-simple.js"></script>

<!-- Define inlined PaperScript associate it with myCanvas -->
<script type="text/paperscript" canvas="myCanvas">

// Cam/follower mechanism simulator by Jumpjack

// 0.3.0
// Added rotating follower; use profileType at beginning of source to change follower type.

// 0.2.1
// Bugfixes for JSON import
// Bugfixes for profile smoothing

// 0.2.0
// Fixed bug of center hole not at center
// Fixed bug of cam profile drawn from top/border rather than from bottom/center
// Fixed bug of reversed cam rotation
// Added circular zoom feature
// Added full calculation at once of pressure angle curve (realtime and commanded)


// 0.1.5
// Added reference hole at center

// Version 0.1.4
// Added pressure angle path (hence circular cam moved to the right to get some space)
// Fixed bug of bad calculation of follower contact point;
// Added orange colorization for invalid concatc point of follower
// Added cam eccentricity (= follower horizontal offset); to do: fix flat path marker for eccentricity !=0
//


// Version 0.1.3
// Added flat path markers
// Added display of rotation angle value
// Added slider for manual rotation
// Added import/export SVG
// Grouped import/export buttons
// Cleaned up code
// Increased resolution of circular path (indepdendent of flat path resolution)

// Version 0.1.2
// Added exporting to SVG format.
// Please use one of these servies to convert to STL for 3d printing:
// https://rawgit.com/ryancalme/svg-to-stl/master/SVGtoSTL.html (source: https://github.com/rcalme/svg-to-stl )
// http://svg2stl.com/

// Version 0.1.1
//	Added pressure angle

// Version 0.1.0 - First public version - 11/11/2021
//	To do:
//	editable flat path;
//	export in SVG format;
//	export in STL format;
//	tunable rotation speed/direction;
//	add speed chart, angle chart, acceleration chart,...

// Known problems:
//	 Can't handle properly two points at same angle in flat path
///////////////////////////////////////////////////////////////


// Init internal variables and constants:
profileType="radius"; // radius/angle
ANGLE_OFFSET 	= -90; // 90: Internally used to have the cam profile starting at top rather than at right
CAM_RADIUS 		= 200;
CAM_CENTER_X 	= 600;
CAM_CENTER_Y	= 230;
GRID_X_OFFSET = 25;
GRID_Y_OFFSET = 25;
PRESSURE_ANGLE_Y_OFFSET = 340; 
ANGLE_Y_OFFSET = 570; // Top coordinate of external follower angle profile
var BASE_CAM_RADIUS = 10; // debug: to be used somewhere else to check for cam validity
DECLI_TOLERANCE = 5;
decliOffset = 24;
rotationAngle=0;

  decliValues = [
{ "x" : 0, "y" : -23.085911002836564},
{ "x" : 1, "y" : -23.011636727869234},
{ "x" : 2, "y" : -22.93054360830765},
{ "x" : 3, "y" : -22.842655673793264},
{ "x" : 4, "y" : -22.74799896741784},
{ "x" : 5, "y" : -22.646601538006347},
{ "x" : 6, "y" : -22.538493431805453},
{ "x" : 7, "y" : -22.423706683580196},
{ "x" : 8, "y" : -22.302275307121352},
{ "x" : 9, "y" : -22.174235285166485},
{ "x" : 10, "y" : -22.03962455873745},
{ "x" : 11, "y" : -21.898483015897597},
{ "x" : 12, "y" : -21.750852479932167},
{ "x" : 13, "y" : -21.596776696955082},
{ "x" : 14, "y" : -21.436301322946086},
{ "x" : 15, "y" : -21.269473910221826},
{ "x" : 16, "y" : -21.096343893345107},
{ "x" : 17, "y" : -20.91696257447641},
{ "x" : 18, "y" : -20.73138310817188},
{ "x" : 19, "y" : -20.539660485632496},
{ "x" : 20, "y" : -20.34185151840905},
{ "x" : 21, "y" : -20.13801482156758},
{ "x" : 22, "y" : -19.928210796320535},
{ "x" : 23, "y" : -19.712501612128527},
{ "x" : 24, "y" : -19.490951188278192},
{ "x" : 25, "y" : -19.26362517494162},
{ "x" : 26, "y" : -19.030590933722618},
{ "x" : 27, "y" : -18.791917517696163},
{ "x" : 28, "y" : -18.54767565094643},
{ "x" : 29, "y" : -18.297937707609684},
{ "x" : 30, "y" : -18.04277769042835},
{ "x" : 31, "y" : -17.782271208822305},
{ "x" : 32, "y" : -17.516495456484215},
{ "x" : 33, "y" : -17.24552918850547},
{ "x" : 34, "y" : -16.96945269803914},
{ "x" : 35, "y" : -16.688347792507624},
{ "x" : 36, "y" : -16.402297769361123},
{ "x" : 37, "y" : -16.111387391394988},
{ "x" : 38, "y" : -15.815702861632575},
{ "x" : 39, "y" : -15.515331797781442},
{ "x" : 40, "y" : -15.210363206270323},
{ "x" : 41, "y" : -14.90088745587468},
{ "x" : 42, "y" : -14.586996250938338},
{ "x" : 43, "y" : -14.268782604199714},
{ "x" : 44, "y" : -13.946340809229898},
{ "x" : 45, "y" : -13.61976641249164},
{ "x" : 46, "y" : -13.289156185026727},
{ "x" : 47, "y" : -12.954608093780678},
{ "x" : 48, "y" : -12.616221272573133},
{ "x" : 49, "y" : -12.274095992722172},
{ "x" : 50, "y" : -11.928333633331844},
{ "x" : 51, "y" : -11.579036651251469},
{ "x" : 52, "y" : -11.226308550715235},
{ "x" : 53, "y" : -10.87025385267186},
{ "x" : 54, "y" : -10.51097806381263},
{ "x" : 55, "y" : -10.148587645307623},
{ "x" : 56, "y" : -9.783189981258852},
{ "x" : 57, "y" : -9.414893346880083},
{ "x" : 58, "y" : -9.043806876412575},
{ "x" : 59, "y" : -8.670040530786286},
{ "x" : 60, "y" : -8.293705065035907},
{ "x" : 61, "y" : -7.914911995481961},
{ "x" : 62, "y" : -7.533773566685943},
{ "x" : 63, "y" : -7.150402718189986},
{ "x" : 64, "y" : -6.7649130510503},
{ "x" : 65, "y" : -6.377418794174787},
{ "x" : 66, "y" : -5.988034770474611},
{ "x" : 67, "y" : -5.596876362839526},
{ "x" : 68, "y" : -5.204059479947669},
{ "x" : 69, "y" : -4.809700521919142},
{ "x" : 70, "y" : -4.413916345824069},
{ "x" : 71, "y" : -4.016824231055654},
{ "x" : 72, "y" : -3.6185418445773894},
{ "x" : 73, "y" : -3.219187206056068},
{ "x" : 74, "y" : -2.8188786528898424},
{ "x" : 75, "y" : -2.41773480514234},
{ "x" : 76, "y" : -2.015874530393125},
{ "x" : 77, "y" : -1.613416908514419},
{ "x" : 78, "y" : -1.2104811963853104},
{ "x" : 79, "y" : -0.8071867925533891},
{ "x" : 80, "y" : -0.4036532018543165},
{ "x" : 81, "y" : -5.7435934880010865e-15},
{ "x" : 82, "y" : 0.40365320185434667},
{ "x" : 83, "y" : 0.8071867925533985},
{ "x" : 84, "y" : 1.2104811963852988},
{ "x" : 85, "y" : 1.6134169085143868},
{ "x" : 86, "y" : 2.0158745303931136},
{ "x" : 87, "y" : 2.4177348051423495},
{ "x" : 88, "y" : 2.8188786528898313},
{ "x" : 89, "y" : 3.219187206056036},
{ "x" : 90, "y" : 3.6185418445773783},
{ "x" : 91, "y" : 4.016824231055664},
{ "x" : 92, "y" : 4.413916345824079},
{ "x" : 93, "y" : 4.80970052191911},
{ "x" : 94, "y" : 5.2040594799476585},
{ "x" : 95, "y" : 5.596876362839536},
{ "x" : 96, "y" : 5.988034770474579},
{ "x" : 97, "y" : 6.377418794174777},
{ "x" : 98, "y" : 6.76491305105027},
{ "x" : 99, "y" : 7.150402718189955},
{ "x" : 100, "y" : 7.533773566685912},
{ "x" : 101, "y" : 7.9149119954819485},
{ "x" : 102, "y" : 8.293705065035914},
{ "x" : 103, "y" : 8.670040530786293},
{ "x" : 104, "y" : 9.043806876412603},
{ "x" : 105, "y" : 9.414893346880072},
{ "x" : 106, "y" : 9.783189981258822},
{ "x" : 107, "y" : 10.148587645307593},
{ "x" : 108, "y" : 10.510978063812637},
{ "x" : 109, "y" : 10.870253852671814},
{ "x" : 110, "y" : 11.226308550715224},
{ "x" : 111, "y" : 11.57903665125146},
{ "x" : 112, "y" : 11.928333633331851},
{ "x" : 113, "y" : 12.274095992722161},
{ "x" : 114, "y" : 12.616221272573123},
{ "x" : 115, "y" : 12.954608093780667},
{ "x" : 116, "y" : 13.289156185026684},
{ "x" : 117, "y" : 13.61976641249163},
{ "x" : 118, "y" : 13.94634080922989},
{ "x" : 119, "y" : 14.268782604199703},
{ "x" : 120, "y" : 14.586996250938345},
{ "x" : 121, "y" : 14.90088745587467},
{ "x" : 122, "y" : 15.210363206270316},
{ "x" : 123, "y" : 15.515331797781418},
{ "x" : 124, "y" : 15.815702861632584},
{ "x" : 125, "y" : 16.111387391394963},
{ "x" : 126, "y" : 16.402297769361116},
{ "x" : 127, "y" : 16.688347792507603},
{ "x" : 128, "y" : 16.96945269803915},
{ "x" : 129, "y" : 17.245529188505458},
{ "x" : 130, "y" : 17.516495456484208},
{ "x" : 131, "y" : 17.782271208822284},
{ "x" : 132, "y" : 18.042777690428327},
{ "x" : 133, "y" : 18.29793770760969},
{ "x" : 134, "y" : 18.547675650946424},
{ "x" : 135, "y" : 18.791917517696167},
{ "x" : 136, "y" : 19.03059093372262},
{ "x" : 137, "y" : 19.263625174941613},
{ "x" : 138, "y" : 19.49095118827819},
{ "x" : 139, "y" : 19.71250161212851},
{ "x" : 140, "y" : 19.928210796320506},
{ "x" : 141, "y" : 20.138014821567584},
{ "x" : 142, "y" : 20.341851518409054},
{ "x" : 143, "y" : 20.53966048563249},
{ "x" : 144, "y" : 20.731383108171872},
{ "x" : 145, "y" : 20.91696257447641},
{ "x" : 146, "y" : 21.0963438933451},
{ "x" : 147, "y" : 21.2694739102218},
{ "x" : 148, "y" : 21.436301322946072},
{ "x" : 149, "y" : 21.59677669695507},
{ "x" : 150, "y" : 21.75085247993216},
{ "x" : 151, "y" : 21.898483015897597},
{ "x" : 152, "y" : 22.039624558737447},
{ "x" : 153, "y" : 22.174235285166496},
{ "x" : 154, "y" : 22.30227530712135},
{ "x" : 155, "y" : 22.423706683580185},
{ "x" : 156, "y" : 22.53849343180545},
{ "x" : 157, "y" : 22.64660153800635},
{ "x" : 158, "y" : 22.747998967417832},
{ "x" : 159, "y" : 22.84265567379326},
{ "x" : 160, "y" : 22.93054360830765},
{ "x" : 161, "y" : 23.011636727869234},
{ "x" : 162, "y" : 23.08591100283656},
{ "x" : 163, "y" : 23.153344424138975},
{ "x" : 164, "y" : 23.21391700979843},
{ "x" : 165, "y" : 23.26761081085051},
{ "x" : 166, "y" : 23.314409916663173},
{ "x" : 167, "y" : 23.35430045965135},
{ "x" : 168, "y" : 23.387270619386246},
{ "x" : 169, "y" : 23.41331062609798},
{ "x" : 170, "y" : 23.43241276357058},
{ "x" : 171, "y" : 23.44457137142844},
{ "x" : 172, "y" : 23.449782846813658},
{ "x" : 173, "y" : 23.448045645453604},
{ "x" : 174, "y" : 23.43936028211853},
{ "x" : 175, "y" : 23.423729330469037},
{ "x" : 176, "y" : 23.401157422293444},
{ "x" : 177, "y" : 23.37165124613529},
{ "x" : 178, "y" : 23.33521954531136},
{ "x" : 179, "y" : 23.291873115320865},
{ "x" : 180, "y" : 23.241624800646505},
{ "x" : 181, "y" : 23.184489490948383},
{ "x" : 182, "y" : 23.12048411665182},
{ "x" : 183, "y" : 23.049627643930588},
{ "x" : 184, "y" : 22.971941069086743},
{ "x" : 185, "y" : 22.887447412329042},
{ "x" : 186, "y" : 22.796171710951487},
{ "x" : 187, "y" : 22.698141011914306},
{ "x" : 188, "y" : 22.59338436382928},
{ "x" : 189, "y" : 22.4819328083521},
{ "x" : 190, "y" : 22.363819370983947},
{ "x" : 191, "y" : 22.239079051285426},
{ "x" : 192, "y" : 22.107748812505374},
{ "x" : 193, "y" : 21.969867570627866},
{ "x" : 194, "y" : 21.82547618284062},
{ "x" : 195, "y" : 21.67461743542803},
{ "x" : 196, "y" : 21.517336031092796},
{ "x" : 197, "y" : 21.353678575709374},
{ "x" : 198, "y" : 21.18369356451386},
{ "x" : 199, "y" : 21.007431367733627},
{ "x" : 200, "y" : 20.824944215661617},
{ "x" : 201, "y" : 20.636286183179415},
{ "x" : 202, "y" : 20.44151317373359},
{ "x" : 203, "y" : 20.24068290277042},
{ "x" : 204, "y" : 20.033854880633424},
{ "x" : 205, "y" : 19.821090394929318},
{ "x" : 206, "y" : 19.60245249236703},
{ "x" : 207, "y" : 19.378005960075683},
{ "x" : 208, "y" : 19.147817306406743},
{ "x" : 209, "y" : 18.91195474122617},
{ "x" : 210, "y" : 18.670488155702337},
{ "x" : 211, "y" : 18.423489101595834},
{ "x" : 212, "y" : 18.17103077005712},
{ "x" : 213, "y" : 17.913187969938225},
{ "x" : 214, "y" : 17.65003710562563},
{ "x" : 215, "y" : 17.381656154399586},
{ "x" : 216, "y" : 17.108124643328157},
{ "x" : 217, "y" : 16.829523625701313},
{ "x" : 218, "y" : 16.545935657013334},
{ "x" : 219, "y" : 16.257444770499617},
{ "x" : 220, "y" : 15.964136452236033},
{ "x" : 221, "y" : 15.66609761580737},
{ "x" : 222, "y" : 15.363416576553035},
{ "x" : 223, "y" : 15.056183025397416},
{ "x" : 224, "y" : 14.744488002272329},
{ "x" : 225, "y" : 14.428423869140053},
{ "x" : 226, "y" : 14.108084282624429},
{ "x" : 227, "y" : 13.7835641662585},
{ "x" : 228, "y" : 13.454959682356431},
{ "x" : 229, "y" : 13.122368203518635},
{ "x" : 230, "y" : 12.785888283778304},
{ "x" : 231, "y" : 12.445619629397315},
{ "x" : 232, "y" : 12.101663069321772},
{ "x" : 233, "y" : 11.754120525303437},
{ "x" : 234, "y" : 11.403094981698795},
{ "x" : 235, "y" : 11.048690454952093},
{ "x" : 236, "y" : 10.691011962773354},
{ "x" : 237, "y" : 10.330165493019075},
{ "x" : 238, "y" : 9.966257972286098},
{ "x" : 239, "y" : 9.599397234226316},
{ "x" : 240, "y" : 9.22969198759411},
{ "x" : 241, "y" : 8.857251784032991},
{ "x" : 242, "y" : 8.482186985613037},
{ "x" : 243, "y" : 8.104608732128696},
{ "x" : 244, "y" : 7.724628908165244},
{ "x" : 245, "y" : 7.342360109945156},
{ "x" : 246, "y" : 6.957915611963344},
{ "x" : 247, "y" : 6.571409333421627},
{ "x" : 248, "y" : 6.182955804471791},
{ "x" : 249, "y" : 5.792670132277933},
{ "x" : 250, "y" : 5.4006679669078625},
{ "x" : 251, "y" : 5.007065467063235},
{ "x" : 252, "y" : 4.611979265659394},
{ "x" : 253, "y" : 4.215526435264392},
{ "x" : 254, "y" : 3.8178244534082735},
{ "x" : 255, "y" : 3.418991167771046},
{ "x" : 256, "y" : 3.019144761263017},
{ "x" : 257, "y" : 2.618403717003746},
{ "x" : 258, "y" : 2.216886783213346},
{ "x" : 259, "y" : 1.814712938024703},
{ "x" : 260, "y" : 1.412001354227852},
{ "x" : 261, "y" : 1.0088713639562585},
{ "x" : 262, "y" : 0.6054424233262556},
{ "x" : 263, "y" : 0.20183407703974532},
{ "x" : 264, "y" : -0.20183407703972808},
{ "x" : 265, "y" : -0.6054424233262384},
{ "x" : 266, "y" : -1.0088713639562412},
{ "x" : 267, "y" : -1.412001354227835},
{ "x" : 268, "y" : -1.8147129380246856},
{ "x" : 269, "y" : -2.21688678321337},
{ "x" : 270, "y" : -2.61840371700377},
{ "x" : 271, "y" : -3.019144761263041},
{ "x" : 272, "y" : -3.41899116777107},
{ "x" : 273, "y" : -3.8178244534082153},
{ "x" : 274, "y" : -4.215526435264416},
{ "x" : 275, "y" : -4.611979265659336},
{ "x" : 276, "y" : -5.007065467063218},
{ "x" : 277, "y" : -5.400667966907845},
{ "x" : 278, "y" : -5.792670132277916},
{ "x" : 279, "y" : -6.182955804471774},
{ "x" : 280, "y" : -6.571409333421611},
{ "x" : 281, "y" : -6.957915611963327},
{ "x" : 282, "y" : -7.342360109945139},
{ "x" : 283, "y" : -7.7246289081652275},
{ "x" : 284, "y" : -8.10460873212868},
{ "x" : 285, "y" : -8.482186985613021},
{ "x" : 286, "y" : -8.857251784033014},
{ "x" : 287, "y" : -9.229691987594094},
{ "x" : 288, "y" : -9.599397234226338},
{ "x" : 289, "y" : -9.966257972286044},
{ "x" : 290, "y" : -10.330165493019097},
{ "x" : 291, "y" : -10.69101196277334},
{ "x" : 292, "y" : -11.048690454952114},
{ "x" : 293, "y" : -11.40309498169878},
{ "x" : 294, "y" : -11.75412052530342},
{ "x" : 295, "y" : -12.101663069321756},
{ "x" : 296, "y" : -12.445619629397335},
{ "x" : 297, "y" : -12.785888283778254},
{ "x" : 298, "y" : -13.122368203518587},
{ "x" : 299, "y" : -13.454959682356419},
{ "x" : 300, "y" : -13.783564166258486},
{ "x" : 301, "y" : -14.108084282624416},
{ "x" : 302, "y" : -14.428423869140072},
{ "x" : 303, "y" : -14.744488002272313},
{ "x" : 304, "y" : -15.056183025397402},
{ "x" : 305, "y" : -15.363416576553023},
{ "x" : 306, "y" : -15.66609761580736},
{ "x" : 307, "y" : -15.964136452235989},
{ "x" : 308, "y" : -16.257444770499603},
{ "x" : 309, "y" : -16.54593565701332},
{ "x" : 310, "y" : -16.8295236257013},
{ "x" : 311, "y" : -17.108124643328114},
{ "x" : 312, "y" : -17.381656154399547},
{ "x" : 313, "y" : -17.650037105625564},
{ "x" : 314, "y" : -17.913187969938186},
{ "x" : 315, "y" : -18.171030770057108},
{ "x" : 316, "y" : -18.42348910159585},
{ "x" : 317, "y" : -18.670488155702326},
{ "x" : 318, "y" : -18.91195474122616},
{ "x" : 319, "y" : -19.147817306406733},
{ "x" : 320, "y" : -19.378005960075672},
{ "x" : 321, "y" : -19.60245249236702},
{ "x" : 322, "y" : -19.821090394929332},
{ "x" : 323, "y" : -20.033854880633417},
{ "x" : 324, "y" : -20.240682902770413},
{ "x" : 325, "y" : -20.4415131737336},
{ "x" : 326, "y" : -20.636286183179408},
{ "x" : 327, "y" : -20.824944215661606},
{ "x" : 328, "y" : -21.0074313677336},
{ "x" : 329, "y" : -21.18369356451383},
{ "x" : 330, "y" : -21.35367857570935},
{ "x" : 331, "y" : -21.51733603109279},
{ "x" : 332, "y" : -21.674617435428036},
{ "x" : 333, "y" : -21.825476182840614},
{ "x" : 334, "y" : -21.969867570627862},
{ "x" : 335, "y" : -22.107748812505367},
{ "x" : 336, "y" : -22.239079051285422},
{ "x" : 337, "y" : -22.363819370983943},
{ "x" : 338, "y" : -22.481932808352102},
{ "x" : 339, "y" : -22.59338436382929},
{ "x" : 340, "y" : -22.698141011914302},
{ "x" : 341, "y" : -22.79617171095148},
{ "x" : 342, "y" : -22.887447412329035},
{ "x" : 343, "y" : -22.97194106908674},
{ "x" : 344, "y" : -23.049627643930577},
{ "x" : 345, "y" : -23.120484116651813},
{ "x" : 346, "y" : -23.184489490948376},
{ "x" : 347, "y" : -23.241624800646505},
{ "x" : 348, "y" : -23.291873115320865},
{ "x" : 349, "y" : -23.335219545311357},
{ "x" : 350, "y" : -23.371651246135286},
{ "x" : 351, "y" : -23.401157422293444},
{ "x" : 352, "y" : -23.423729330469037},
{ "x" : 353, "y" : -23.43936028211853},
{ "x" : 354, "y" : -23.448045645453604},
{ "x" : 355, "y" : -23.449782846813658},
{ "x" : 356, "y" : -23.44457137142844},
{ "x" : 357, "y" : -23.43241276357058},
{ "x" : 358, "y" : -23.41331062609798},
{ "x" : 359, "y" : -23.38727061938625},
{ "x" : 360, "y" : -23.085911002836564},
  /*
    {"x" : 0, "y" : -23.085910996832},
    {"x" : 30, "y" : -18.0427776798567},
    {"x" : 60, "y" : -8.29370504807597},
    {"x" : 90, "y" : 4.01682425052934},
    {"x" : 120, "y" : 14.9008874723579},
    {"x" : 150, "y" : 22.0396245665871},
    {"x" : 180, "y" : 23.1204841125486},
    {"x" : 210, "y" : 18.1710307535317},
    {"x" : 240, "y" : 8.1046087060629},
    {"x" : 270, "y" : -3.81782448237535},
    {"x" : 300, "y" : -15.0561830491583},
    {"x" : 330, "y" : -21.9698675820173},
    {"x" : 360, "y" : -23.085910996832}*/
  ];

	
CAM_WIDTH 					= config.pathWidth;
CAM_LINE_COLOR 				= config.lineColor;
CAM_FILL_COLOR 				= config.fillColor;
CAM_POINTS_COLOR 			= config.pointsColor;
CAM_FLATPATH_COLOR 			= config.flatpathColor;
CAM_FLATPATH_POINTS_COLOR	= config.flatpathPointsColor;
CAM_FLATPATH_WIDTH 			= config.flatpathWidth;
CIRCULAR_PRECISION			= 1;
FOLLOWER_LENGTH 			= config.followerLength; 
FOLLOWER_COLOR 				= config.followerColor;
FOLLOWER_WIDTH 				= config.followerWidth;
OSCILLATING_FOLLOWER_COLOR		= config.followerColor; // debug
OSCILLATING_FOLLOWER_WIDTH     = 1;  // debug
OSCILLATING_FOLLOWER_LENGTH = 120;
followerOffsetX 			= config.initialFollowerOffsetX;
followerOffsetY 			= config.initialFollowerOffsetY;
FOLLOWER_TOP 				= new Point(CAM_CENTER_X + followerOffsetX, CAM_CENTER_Y + followerOffsetY - CAM_RADIUS);
FOLLOWER_BOTTOM 			= new Point(CAM_CENTER_X + followerOffsetX, CAM_CENTER_Y + followerOffsetY - CAM_RADIUS - FOLLOWER_LENGTH);
MAX_PRESSURE = config.maxPressure;
NORMAL_COLOR = config.normalColor;
NORMAL_WIDTH = config.normalWidth;
ZERO_ZERO =	 new Point(GRID_X_OFFSET,				GRID_Y_OFFSET);
UPPER_POINT = new Point(GRID_X_OFFSET,				GRID_Y_OFFSET + CAM_RADIUS);
BOTTOM =		new Point(GRID_X_OFFSET + CAM_CENTER_X, GRID_Y_OFFSET + CAM_CENTER_Y + 200);
FLAT_PROFILE_ORIGIN =	new Point(GRID_X_OFFSET,		 GRID_Y_OFFSET + CAM_RADIUS);


// Oscillating follower prototype:
var oscillatingCenterX = CAM_CENTER_X - 120;
var oscillatingCenterY = CAM_CENTER_Y - 40;
var oscillatingPivot = {x : oscillatingCenterX, y: oscillatingCenterY}
angVal = 0;


var pressureAngleCalculated = false;

document.getElementById("btnStart").addEventListener("click", startRotation);
document.getElementById("btnStop").addEventListener("click", stopRotation);
document.getElementById("btnReset").addEventListener("click", resetRotation);
document.getElementById("btnShow").addEventListener("click", toggleCamSelection);
document.getElementById("fileinput").addEventListener("change", loadFile);
document.getElementById("SVGfileinput").addEventListener("change", importSVG);
document.getElementById("btnExportSVG").addEventListener("click", exportSVG);
document.getElementById("btnSave").addEventListener("click", saveCam);
document.getElementById("rngRotation").addEventListener("change", rotateBySlider);
document.getElementById("rngRotation").addEventListener("input", rotateBySlider);
document.getElementById("btnGrid").addEventListener("click", toggleCircularGrid);
document.getElementById("rngFollowerOffset").addEventListener("change", moveFollower);
document.getElementById("rngFollowerOffset").addEventListener("input", moveFollower);
document.getElementById("btnFollowerReset").addEventListener("click", function () { rngFollowerOffset.value = 0; moveFollower() });
document.getElementById("btnRecalcPressure").addEventListener("click", fullRotation);
document.getElementById("btnSmooth").addEventListener("click", function () {flatPath.smooth({ type: 'continuous' }); createCam("smooth");});

document.getElementById("btnReload").onclick=function() {
 update("RELOAD");
};

document.getElementById("rngZoom").oninput=function() {
  update("ZOOM");
};

document.getElementById("rngOffset").oninput=function() {
  update("ZOOM");
};


createObjects();
initVariables();
fullRotation();

/////////////////////////////////////////////////////


function createObjects() {
	flatPath = new Path();
	follower = new Path();
	oscillatingFollower = new Path();
	normalVector = new Path();
	camPath = new Path();
	verticalLine = new Path();
	verticalLine.strokeColor = '#0000FF';
	verticalLine.moveTo(GRID_X_OFFSET, GRID_Y_OFFSET);
	verticalLine.add(GRID_X_OFFSET, GRID_Y_OFFSET + ANGLE_Y_OFFSET + 180);
	verticalLine.bringToFront();
	

	pressureAnglePath  = new Path({
		strokeColor: '#000000',
		strokeWidth: 1,
		visible:true
	});


	anglePath  = new Path({
		strokeColor: '#000000',
		strokeWidth: 1,
		visible:true
	});
	

	// Tracker for oscillating follower angle path:
	anglePointInitialY = ANGLE_Y_OFFSET	+ GRID_Y_OFFSET; // Vertical position in canvas
	anglePointInitialPosition = new Point();
	anglePointInitialPosition.x = GRID_X_OFFSET;
	anglePointInitialPosition.y = anglePointInitialY;
	anglePoint = new Path.Circle({
		center : anglePointInitialPosition,
		radius : 5,
		strokeColor : '#000000',
		fillColor : '#FFFF00'
	});
	createAnglePath();


	camStaticReference = new Path.Circle();

	// Tracker for pressure angle path:
	pressureAnglePointInitialY = PRESSURE_ANGLE_Y_OFFSET	+ GRID_Y_OFFSET;
	pressureAnglePointInitialPosition = new Point();
	pressureAnglePoint = new Path.Circle({
		center : pressureAnglePointInitialPosition,
		radius : 5,
		strokeColor : '#000000',
		fillColor : '#FFFF00'
	});
	pressureAnglePointInitialPosition.x = GRID_X_OFFSET
	pressureAnglePointInitialPosition.y = pressureAnglePointInitialY;
	createPressureAnglePath();
	

	flatPathBall =	new Path.Circle({
		center : FLAT_PROFILE_ORIGIN.clone(),
		radius : 5,
		strokeColor : '#000000',
		fillColor : '#00AA00'
	});

	origin = new Point(CAM_CENTER_X,CAM_CENTER_Y);

	INITIAL_FOLLOWER = new Path([origin,origin]);
	INITIAL_OSCILLATING_FOLLOWER = new Path([new Point(oscillatingPivot.x + OSCILLATING_FOLLOWER_LENGTH,oscillatingPivot.y), oscillatingPivot]);

	// Invisible object, used internally to determine local radius of cam profile
  // Intersector is the vertical line which crosses the flat path, and is used to determine "local cam radius"
	intersectorStart = new Point(0 + GRID_X_OFFSET, CAM_RADIUS + GRID_Y_OFFSET);
	intersectorEnd = new Point(0 + GRID_X_OFFSET, 0 + GRID_Y_OFFSET);
	intersector = new Path([intersectorStart,intersectorEnd]); 
	
	// Invisibile object, static: a vertical line crossing the cam, used to determine follower contact point and the pressur angle
	intersectorRayStart = new Point(CAM_CENTER_X + followerOffsetX, CAM_CENTER_Y + followerOffsetY + 100);
	intersectorRayEnd = new Point(CAM_CENTER_X	+ followerOffsetX, CAM_CENTER_Y	+ followerOffsetY - CAM_RADIUS - 100);
	intersectorRay = new Path([intersectorRayStart,intersectorRayEnd]); 


	camStartPoint = new Point();
	CSR= camStartPoint.clone();
	drawGrid({x:0, y:0}, {x:360, y:CAM_RADIUS}, 10, 10);
}



function initVariables() {
	if (camPath) {camPath.parent.project.activeLayer.removeChildren()};
	createObjects();
	verticalLines = [];
	radii = []; // Reference lines
	radiiReference = [];
	flatPathPointMarker = [];
	allowRotation = false;
	camCreated = false;
	flatPath.name = "flatPath"
	camPath.name = "camPath"
	pressureAnglePath.name = "pressureAnglePath"
	camStaticReference.visible=false;
	normalVector.strokeColor = NORMAL_COLOR;
	normalVector.strokeWidth = NORMAL_WIDTH;
	minPressureAngle = 1000;
	maxPressureAngle = -1000;
	pointToAdd = null;
	pressureAngle= 0;
	prevX = 0;
	prevY = 0;
	contactExists = false;
	camType = "JSON"; // Default preloaded cam
	totAngle=1;
	intersectorRay.strokeColor = '#000000';
	camCreated = false;

	assignCamData();
	

  ///////////// Declinazione:
/*	for ( ind = 0; ind < 360; ind += 1) {
		var declDeg = 23.45 * Math.sin((360 * ((284 + ind)/365))*Math.PI/180);
    tempcam.value += ("{ \"x\" : " +  ind + ", \"y\" : " + declDeg + "},\n");
	}
*/

	createCam();
 
	fileContents.value = JSON.stringify(camData,null,4);
}





function drawMarkers() {
	localAngle = totAngle;
	if (localAngle < 0) localAngle += 360;
	if (localAngle > 360) localAngle = 360 - localAngle;
	pressureAngleCalculated = false;
	calculatePressureAngle();
	pressureAnglePoint.position.x = localAngle + GRID_X_OFFSET  + 0;
	pressureAnglePoint.position.y = pressureAnglePointInitialY + pressureAngle;

	anglePoint.position.x = localAngle + GRID_X_OFFSET + 0;
	anglePoint.position.y = anglePointInitialY - angVal;

/*	flatPathBall.position.x = localAngle	+ GRID_X_OFFSET  + 0;
	flatPathBall.position.y =  camData.segments[totAngle].point.y + CAM_RADIUS	+ GRID_Y_OFFSET;
	flatPathBall.bringToFront();
*/
	verticalLine.segments[0].point.x = localAngle + GRID_X_OFFSET;
	verticalLine.segments[1].point.x = localAngle + GRID_X_OFFSET;
	verticalLine.bringToFront();
}



function createAnglePath() {
	anglePath.clear();
	// Create a flat path; it will be updated in realtime during cam rotation:
	for (var i=1; i < 360; i++) { // debug 1 o 0?
		anglePath.add(new Point(360 - i + GRID_X_OFFSET, anglePointInitialY  ));
	}	
	drawTicks(GRID_X_OFFSET, ANGLE_Y_OFFSET, anglePointInitialY, 23.7, 'Follower angle');
}

function createPressureAnglePath() {
	pressureAnglePath.clear();
	// Create a flat path; it will be updated in realtime during cam rotation:
	for (var i=1; i < 360; i++) { // debug 1 o 0?
		pressureAnglePath.add(new Point(360 - i + GRID_X_OFFSET, pressureAnglePointInitialY  ));
	}
	drawTicks(GRID_X_OFFSET, PRESSURE_ANGLE_Y_OFFSET, pressureAnglePointInitialY, MAX_PRESSURE, 'Pressure Angle');
}
	
function drawTicks(x_off, y_off, initY, maxVal, label) {	
// Draw ticks on left axis:

 // Tick +90
	dummy = new Path();
	dummy.strokeColor = '#000000';
	dummy.moveTo(new Point(0 + x_off, initY - 90 ));
	dummy.add(new Point(360 + x_off, initY - 90  ));
	dummy.add(new Point(360 + x_off, initY + 90  ));
	dummy.add(new Point( 0 + x_off, initY + 90  ));
	dummy.add(new Point( 0 + x_off, initY - 90  ));
	var pressureText = new paper.PointText();
	pressureText.content='+90';
	pressureText.position.y = initY -	90  ;

 // Tick Max
	dummy = new Path();
	dummy.strokeColor = '#FF0000';
	dummy.moveTo(new Point(0 + x_off, initY - maxVal  ));
	dummy.add(new Point(360 + x_off, initY - maxVal  ));
	var pressureText = new paper.PointText();
	pressureText.content='Max';
	pressureText.position.y = initY - maxVal - 0  ;


 // Tick -90
	dummy = new Path();
	dummy.strokeColor = '#000000';
	dummy.moveTo(new Point(0 + x_off, initY  ));
	dummy.add(new Point(360 + x_off, initY  ));
	var pressureText = new paper.PointText();
	pressureText.content='-90';
	pressureText.position.y = initY + 90  ;

 // Tick Min
	dummy = new Path();
	dummy.strokeColor = '#FF0000';
	dummy.moveTo(new Point(0 + x_off, initY + maxVal  ));
	dummy.add(new Point(360 + x_off, initY + maxVal 	));
	var pressureText = new paper.PointText();
	pressureText.content='Min';
	pressureText.position.y = initY + maxVal - 0 ;//+ y_off  ;

	// Chart title:
	dummy = new Path();
	dummy.strokeColor = '#000000';
	dummy.moveTo(new Point(0 + x_off, initY + 90  ));
	dummy.add(new Point(360 + x_off, initY + 90  ));
	var pressureText = new paper.PointText();
	pressureText.content=label;
	pressureText.position.x =  x_off + 180;
	pressureText.position.y =  y_off -90 ;
}


function moveFollower() {
	followerOffsetX = rngFollowerOffset.value*1;
	follower.segments[0].point.x = FOLLOWER_TOP.x + followerOffsetX;
	intersectorRay.segments[0].point.x = FOLLOWER_TOP.x + followerOffsetX;
	follower.segments[1].point.x = FOLLOWER_TOP.x + followerOffsetX;
	intersectorRay.segments[1].point.x = FOLLOWER_TOP.x + followerOffsetX;
	normalVector.bringToFront();
	//rotateBySlider();

	if (chkPressReal.checked) {fullRotation()};
}


function importSVG() {
// Load SVG file containing definition of circular path //
	var input, file, fr;
	if (typeof window.FileReader !== 'function') {
	alert("The file API isn't supported on this browser yet.");
	return;
	}
	input = document.getElementById('SVGfileinput');
	if (!input) {
	alert("Um, couldn't find the fileinput element.");
	}
	else if (!input.files) {
	alert("This browser doesn't seem to support the `files` property of file inputs.");
	}
	else if (!input.files[0]) {
	}
	else {
	file = input.files[0];
	fr = new FileReader();
	fr.onload = processReceivedTextSVG;
	fr.readAsText(file);
	}
}


function processReceivedTextSVG(e) {
	console.log("SVG loaded, importing...",e);
	flatPath.remove();
	camPath.clear();
	camStaticReference.remove();
	CSR.remove();
	camStartPoint.remove();
	for (var i=0; i< flatPathPointMarker.length; i++) {
		flatPathPointMarker[i].remove();
	}


	var lines = e.target.result;
	filename.innerHTML = SVGfileinput.value;
	SVGfileinput.value="";
		fileContentsSVG.value=lines;
	fileContents.value = "";
	rawPathStart = lines.indexOf("path");
	rawPathStart = lines.indexOf("d=", rawPathStart+1) + 3;
	rawPathEnd = lines.indexOf('"', rawPathStart+1) - 1;
	rawPathLen = rawPathEnd - rawPathStart + 1;
	rawPath = lines.substr(rawPathStart, rawPathLen);
	try {
		camPath = new Path(rawPath);
	} catch (e){
		alert("Invalid SVG file:" + e);
		console.log("Invalid SVG file:" + e);
		return -1;
	}


		camStartPoint = new Path.Circle({
			center: startPosition,
			radius: 5,
			strokeColor: '#000000',
			fillColor: '#FFFF00'
	});
	CSR = camStartPoint.clone()

	// Cam first point:
	camStart = new Point(startPosition.x, startPosition.y); // Define start position of circular cam path
	camPath.moveTo(camStart); // Set first point of cam path to user-defined start position
	camPath.position = origin;

	camPath.strokeColor = CAM_LINE_COLOR;
	camPath.selectedColor = CAM_POINTS_COLOR;
	camPath.strokeWidth = CAM_WIDTH;
	camPath.fillColor = CAM_FILL_COLOR;
	camCreated = true;

	camStaticReference = camPath.clone();
	camStaticReference.visible=false;
	camPath.visible = true;
	camType = "SVG";
console.log("Cam SVG loading complete.");
}


function loadFile() {
// Load json file containing definition of flat path //
	var input, file, fr;

	if (typeof window.FileReader !== 'function') {
	alert("The file API isn't supported on this browser yet.");
	return;
	}

	input = document.getElementById('fileinput');

	if (!input) {
	alert("Um, couldn't find the fileinput element.");
	}
	else if (!input.files) {
	alert("This browser doesn't seem to support the `files` property of file inputs.");
	}
	else if (!input.files[0]) {
	}
	else {
	file = input.files[0];
	try {
		fr = new FileReader();
		fr.onload = processReceivedText;
		fr.readAsText(file);
	} catch (e) {
		alert("Error loading file");
		console.log("Error loading file, " , e);
	}
	}
}




function processReceivedText(e) {
console.log("Process...");
	var lines = e.target.result;
console.log(e.target.result);
	try {
		camData = JSON.parse(lines);
		fileContents.value = lines;
		fileContentsSVG.value = "";
	} catch (e){
		alert("Invalid JSON file:" + e);
		console.log("Invalid JSON file:" + e);
		return -1;
	}

	flatPath.remove();
	camPath.clear();
	camStaticReference.remove();
	CSR.remove();
	camStartPoint.remove();
	for (var i=0; i< flatPathPointMarker.length; i++) {
		flatPathPointMarker[i].remove();
	}
	camCreated = false;
	fileinput.value="";
	console.log("Recreating cam from JSON...");
console.log("PRIMA=",camPath.segments.length);
	assignCamData();
	createCam();
	resetRotation();
console.log("DOPO=",camPath.segments.length);

	camPath.bringToFront();
	camStartPoint.bringToFront();
	camType = "JSON";
	update("ZOOM");
}



function saveCam () {
		allowRotation = false;
		resetRotation();
		var filename = "cam.json";
		var text = fileContents.value;
		var blob = new Blob([text], {type:'text/plain'});
		var link = document.createElement("a");
		link.download = filename;
		link.href = window.URL.createObjectURL(blob);
		document.body.appendChild(link);
		link.click();
		setTimeout(function()	{
			document.body.removeChild(link);
			window.URL.revokeObjectURL(link.href);
		}, 100);
	}




function update(updateType) {
// Security restrictions prevent from reloading a modified file without user intervention, hence "reload"
// is performed on temporary data shown on the page
	if(updateType === "RELOAD") {
		try {
			console.log("JSON REloaded, parsing...");
			camData = JSON.parse(fileContents.value);
			console.log("cam data Reloaded: ", camData);
			document.getElementById("spnStatus").innerHTML = "Cam data reloaded";
		} catch (e){
				document.getElementById("spnStatus").innerHTML = "Invalid JSON data:" + e.toString();
				alert("Invalid JSON file:" + e);
				console.log("Invalid JSON file:" + e);
			return;
		}
	}

	initVariables();
	resetRotation();
	camPath.bringToFront();
	camPath.visible=true;
	camStartPoint.bringToFront();

}




function assignCamData() {
	CAM_ROTATION_SPEED 			= camData.rotSpeed;
	CAM_STEPS_WIDTH 			= camData.stepsWidth;
	ROTATION_DIRECTION 			= camData.rotationDir;


	camPath.clear();
	camPath.strokeColor = CAM_LINE_COLOR;
	camPath.selectedColor = CAM_POINTS_COLOR;
	camPath.strokeWidth = CAM_WIDTH;
	camPath.fillColor = CAM_FILL_COLOR;

	flatPath.clear();
	flatPath.strokeColor = CAM_FLATPATH_COLOR;
	flatPath.selectedColor = CAM_FLATPATH_POINTS_COLOR;
	flatPath.strokeWidth = CAM_FLATPATH_WIDTH;


	follower.remove();
	follower = INITIAL_FOLLOWER.clone();
	follower.segments[0].point = FOLLOWER_TOP;
	follower.segments[1].point = FOLLOWER_BOTTOM;
	follower.segments[0].point.x = FOLLOWER_TOP.x + followerOffsetX;
	follower.segments[1].point.x = FOLLOWER_BOTTOM.x + followerOffsetX;
	follower.strokeColor = FOLLOWER_COLOR;
	follower.strokeWidth = FOLLOWER_WIDTH;
	follower.bringToFront();
	

	normalVector.bringToFront();

	drawGrid({x:0, y:0}, {x:360, y:CAM_RADIUS}, 10, 10);

}




function startRotation() {
	if (!camCreated) return -1;
	allowRotation=true;
}




function stopRotation() {
	if (!camCreated) return -1;
	allowRotation=false;
}

function fullRotation() {
	var temp = rngRotation.value * 1.0;
	for (var i=1; i < 360; i += CAM_ROTATION_SPEED) {
		rotateCam(ROTATION_DIRECTION * CAM_ROTATION_SPEED, "full");
	}
	rotateCam(temp, "full");

}

function rotateCam(angle, type) {

	camPath.remove();
	camPath = camStaticReference.clone();
	camStartPoint.remove();
	camStartPoint = CSR.clone();



	if (type == "manual") {
		totAngle = angle; // Manual --> absolute angle
		rngRotation.value = totAngle;
	} else {
		// anim --> delta angle
		totAngle += angle;
		if (totAngle > 360) {
			totAngle = totAngle - 360;
		}
		if (totAngle < 0) {
			totAngle =	totAngle + 360;
		}
		rngRotation.value = totAngle;
	}
	lblAngle.innerHTML = rngRotation.value;
	spnCount.innerHTML = camPath.parent.children.length;


	camPath.rotate(totAngle, origin);

	  ///// Rotate the rotating follower
	  rotationAngle = findYForAngle(totAngle, decliValues) + decliValues[0].y;// -  decliOffset ;
		oscillatingFollower.remove();
		oscillatingFollower = INITIAL_OSCILLATING_FOLLOWER.clone();
		oscillatingFollower.strokeColor = OSCILLATING_FOLLOWER_COLOR;
		oscillatingFollower.strokeWidth = OSCILLATING_FOLLOWER_WIDTH;
	  oscillatingFollower.rotate(rotationAngle, oscillatingPivot);
	  oscillatingFollower.bringToFront();
	  ///////////////

angVal = rotationAngle;

	// Rotate reference lines
	for (var i=0; i< radii.length; i++) {
		if (radii[i]) {
			radii[i].remove();
		}
		radii[i] = radiiReference[i].clone();
		radii[i].strokeColor = "#FF0000";
		radii[i].rotate(totAngle, origin);
	}

	if (type === "full") {
		if (chkPressReal.checked) {
			calculatePressureAngle(); // In case of full rotation at once, redraw pressure angle plot only if checkbox checked
		} else {
			// Don't draw
		}
	} else {
			calculatePressureAngle();
	}

	indexPressure = 360 - (totAngle - 1);
	if (indexPressure < 0) indexPressure = 0;
	if (indexPressure >360 ) indexPressure = indexPressure - 360;
	if ( pressureAngle	< minPressureAngle) { minPressureAngle = pressureAngle}
	if ( pressureAngle	> maxPressureAngle) { maxPressureAngle = pressureAngle}
	try {
		pressureAnglePath.segments[indexPressure].point.y = pressureAnglePointInitialY + pressureAngle;
		anglePath.segments[indexPressure].point.y = anglePointInitialY - angVal;
	} catch (e) {
		//console.log("Warning, cannot update pressure angle curve: ", e);
	}
	indexPressure++;
	if (indexPressure > 359) {
		indexPressure = indexPressure - 360;
	}
	try {
		pressureAnglePath.segments[indexPressure].point.y = pressureAnglePointInitialY + pressureAngle + 1;
		anglePath.segments[indexPressure].point.y = anglePointInitialY - angVal + 1;
		//var tempX = pressureAngleCircles[indexPressure].getPosition().x;
		//var tempY = pressureAnglePointInitialY + pressureAngle + 1;
		//pressureAngleCircles[indexPressure].setPosition(tempX,tempY); // DEBUG
	} catch (e) {
		//console.log("Warning 2, cannot update pressure angle curve: ", e);
	}

	drawMarkers();

	camStartPoint.rotate(totAngle, origin);
	camPath.bringToFront();
	camStartPoint.bringToFront();

	setCircularGridVisibvility(gridToFront);

	camStaticReference.visible=false;
	camPath.visible = true;
	normalVector.bringToFront();
  	oscillatingFollower.bringToFront();

	if (profileType === "radius") {
	  oscillatingFollower.remove();
	}

	if (profileType === "angle") {
	  follower.remove();
	}

}


function findYForAngle(angle, decliValues) {
  for ( i = 0; i < decliValues.length - 1; i++) {
     x1 = decliValues[i].x;
     y1 = decliValues[i].y;
     x2 = decliValues[i + 1].x;
     y2 = decliValues[i + 1].y;

    if (angle === x1) {
      return y1; // Restituisce il valore di y se angle corrisponde a x1
    } else if (angle === x2) {
      return y2; // Restituisce il valore di y se angle corrisponde a x2
    } else if (angle > x1 && angle < x2) {
      // Calcola il valore interpolato di y
       interpolatedY = y1 + ((angle - x1) / (x2 - x1)) * (y2 - y1);
      return interpolatedY;
    }
  }
  return null; // Restituisce null se angle non è nel range disponibile
}




function rotateBySlider() {
	rotateCam(rngRotation.value * 1, "manual");
}


function toggleCamSelection() {
	if (!camCreated) return -1;
	camPath.fullySelected = !camPath.fullySelected;
	flatPath.fullySelected = !flatPath.fullySelected;
}

function toggleCircularGrid() {
	gridToFront = !gridToFront;
	setCircularGridVisibvility(gridToFront)
}

function setCircularGridVisibvility(front){
	// Rays:
	for (var i=0; i < radii.length; i++) {
		if (front) {
			radii[i].bringToFront();
		} else {
			radii[i].sendToBack();
		}
	}

	// Circles:
	for (var i=0; i < gridCirclesCount; i++) {
		if (front) {
			gridCircles[i].bringToFront();
		} else {
			gridCircles[i].sendToBack();
		}
	}
}

function onFrame(event) {
	///// At each frame rotate cam and update follower position ////

	if (!camCreated) return -1;
	if (allowRotation === false) return;

	// Rotate cam
	rotateCam(ROTATION_DIRECTION * CAM_ROTATION_SPEED, "anim");
//console.log("ROTATION_DIRECTION * CAM_ROTATION_SPEED",ROTATION_DIRECTION * CAM_ROTATION_SPEED);
	follower.bringToFront();
	normalVector.bringToFront();
	camStartPoint.bringToFront();

}


function calculatePressureAngle() {
	// Calculate point of contact of follower with cam:
	intersections = intersectorRay.getIntersections(camPath);
	if (intersections.length>0) {
		followerContactPoint = intersections[intersections.length-1].point;
		prevX = followerContactPoint.x;
		prevY = followerContactPoint.y;
		follower.strokeColor = FOLLOWER_COLOR;
		contactExists = true;
		spnStatus.innerHTML = "OK";
	} else {
		followerContactPoint = new Point(prevX, CAM_CENTER_Y + CAM_RADIUS);
		follower.strokeColor = '#FFAA00';
		contactExists=false;
		spnStatus.innerHTML = "ERROR! no follower/cam intersection found!";
		//return -1;
	}

	// Update follower position:
	follower.segments[1].point.y = followerContactPoint.y;
	follower.segments[0].point.y = followerContactPoint.y - FOLLOWER_LENGTH;

	

	if (!contactExists) return -1;

	contactOffset = camPath.getOffsetOf(followerContactPoint);
	normal = camPath.getNormalAt(contactOffset)*50;
	normal2 = normal.rotate(origin);
	if (normalVector)	 {
		normalVector.clear();
		normalVector.remove();
		normalVector = new Path({
			segments: [followerContactPoint	, followerContactPoint - normal] // Draw segment normal to cam profile
		});
		normalVector.strokeColor = NORMAL_COLOR;
		normalVector.strokeWidth = NORMAL_WIDTH;
		normalVector.bringToFront();
	} else {
console.log("NO NORMAL VECTOR?!?"); // debug delete this part?
		normalVector[0]= new Point(followerContactPoint, followerContactPoint + normal);
		normalVector.bringToFront();
	}

	pressureAngle =  normal.angle - 90;
	message = "";
//console.log("NORM=",normal.angle, normal.angle);
	if (Math.abs(-pressureAngle * ROTATION_DIRECTION) > MAX_PRESSURE) {
		spnPressure.style="color:#FF0000;";
		follower.strokeColor = '#FF0000';
		//spnStatus.innerHTML = "WARNING! Pressure angle > " + MAX_PRESSURE;
		message = "TOO HIGH!";
	} else {
		spnPressure.style="color:#000000;";
		follower.strokeColor =	FOLLOWER_COLOR;
		//spnStatus.innerHTML = "ok";
		message = "";
	}
	normalVector.bringToFront();
	document.getElementById("spnPressure").innerHTML = pressureAngle.toFixed(0) + " " + message;
	pressureAngleCalculated = true;
}


function resetRotation () {
// debug: aggiustare in modo che non cancelli la camma caricata ////
	if (!camCreated) return -1;

	rngRotation.value = 1;
	rotateCam(0,"manual");
	camStartPoint.bringToFront();

}




function drawGrid(topLeft, bottomRight, gridStepX, gridStepY) {
	gridToFront = false;
	gridCircles = [];
	gridCirclesCount = 0;
	// Draw vertical lines of grid
	for (var x=topLeft.x; x < bottomRight.x; x += gridStepX) {
		segment = new Path();
		segment.strokeColor = '#DDDDDD';
		segment.strokeWidth = 1;
		segment.moveTo(new Point(x	+ GRID_X_OFFSET, topLeft.y + GRID_Y_OFFSET));
		segment.add(new Point(x + GRID_X_OFFSET	, bottomRight.y + GRID_Y_OFFSET));
	}

	// Draw horizontal lines of grid and circles on cam
	for (var y=topLeft.y; y <= bottomRight.y; y += gridStepY) {
		segment = new Path();
		segment.strokeColor = '#DDDDDD';
		segment.strokeWidth = 1;
		segment.moveTo(new Point(0 + GRID_X_OFFSET, y + GRID_Y_OFFSET));
		segment.add(new Point(bottomRight.x + GRID_X_OFFSET, y + GRID_Y_OFFSET));

		gridCircles.push(new Path.Circle({
				center: new Point(CAM_CENTER_X, CAM_CENTER_Y),
				radius: y,
				strokeColor: '#BBBBBB'
		}));

		gridCirclesCount++;
	}

	// Draw top and bottom line of grid

	// Top:
	segment = new Path();
	segment.strokeColor = '#000000';
	segment.moveTo(ZERO_ZERO);
	segment.add(new Point(bottomRight.x + GRID_X_OFFSET,0 + GRID_Y_OFFSET));


	// Bottom
	segment = new Path();
	segment.strokeColor = '#000000';
	segment.moveTo(UPPER_POINT);
	segment.add(new Point(bottomRight.x + GRID_X_OFFSET,CAM_RADIUS + GRID_Y_OFFSET));
}

function drawFlatPathFromJSONdata() {
		// Draw flat path of cam on grid:
console.log("drawFlatPathFromJSONdata");		
		var start = FLAT_PROFILE_ORIGIN.clone();
		flatPath.moveTo(start);
		for (var i=0; i < camData.segments.length; i++) {
			flatPathPoint = new Point(camData.segments[i].x + GRID_X_OFFSET, CAM_RADIUS - rngZoom.value * (camData.segments[i].y) + GRID_Y_OFFSET - rngOffset.value); // debug
			flatPath.add(flatPathPoint);
				flatPathPointMarker.push(new Path.Circle({
					 center: flatPathPoint,
					radius: 5,
					strokeColor: '#000000',
					fillColor: '#FF0000'
			}));
		}
		flatPath.bringToFront();
}



function drawAnglePath() {
		var start = FLAT_PROFILE_ORIGIN.clone();
		flatPath.moveTo(start);
		for (var i=0; i < camData.segments.length; i++) {
			flatPathPoint = new Point(camData.segments[i].x + GRID_X_OFFSET, CAM_RADIUS - rngZoom.value * (camData.segments[i].y) + GRID_Y_OFFSET - rngOffset.value); // debug
			flatPath.add(flatPathPoint);
				flatPathPointMarker.push(new Path.Circle({
					 center: flatPathPoint,
					radius: 5,
					strokeColor: '#000000',
					fillColor: '#FF0000'
			}));
		}
		flatPath.bringToFront();
}


function createCam(param) {
	camPath.clear();
	camCreated = true;

	if (param === "smooth") {
		// flat path already drawn and smoothed
	} else {
		drawFlatPathFromJSONdata();
	}

	//// Create the circular profile of the cam starting from the flat profile ////
	intersector.position.x = 0 + GRID_X_OFFSET; // Intersector is the vertical line which crosses the flat path, and is used to determine "local cam radius"
	intersector.visible=true;
	intersection = flatPath.getIntersections(intersector);
	startPosition = new Point(CAM_CENTER_X + (CAM_RADIUS-intersection[0].point.y) + GRID_X_OFFSET, CAM_CENTER_Y ) ; // Start from right, then proceed CCW
	startPosition = startPosition.rotate(ANGLE_OFFSET, origin); // Rotate startig point from righ side to top side
	var vector = origin + startPosition; // Create point w.r.t a base position, i.e. a vector

	camStartPoint = new Path.Circle({
			center: startPosition,
			radius: 1,
			strokeColor: '#000000',
			fillColor: '#FFFF00'
	});
	CSR = camStartPoint.clone()

  if (profileType === "radius") {
  	// Cam first point:
  	camStart = new Point(startPosition.x, startPosition.y); // Define start position of circular cam path
  	camPath.moveTo(camStart); // Set first point of cam path to user-defined start position
  	// Draw cam points:

  	for (var degr = 0 ; degr <= 360; degr += CIRCULAR_PRECISION) {
  		intersector.position.x = degr + GRID_X_OFFSET; // "Move" intersector along flat profile
  		intersection = flatPath.getIntersections(intersector); // Calculate intersection to determine cam local radius
  		if (intersection.length >0) {
  			vector.angle = -degr + ANGLE_OFFSET; // Rotate the vector at each step/segment of the flat path
  			vector.length = (CAM_RADIUS - intersection[0].point.y + GRID_Y_OFFSET); // Set cam local radius
  			relativePoint = origin + vector; // Calculate position of point representing local radius of cam
  			camPath.add(new Point(relativePoint.x, relativePoint.y)); // Add point to circular profile
  		}
  	}
  }

  if (profileType === "angle") {
  	for (var totAngle = 0 ; totAngle <= 360; totAngle += CIRCULAR_PRECISION) {

    ///// Rotate the rotating follower
    rotationAngle = findYForAngle(totAngle, decliValues) + decliValues[0].y;// -  decliOffset ;
  	oscillatingFollower.remove();
  	oscillatingFollower = INITIAL_OSCILLATING_FOLLOWER.clone();
  	oscillatingFollower.strokeColor = OSCILLATING_FOLLOWER_COLOR;
  	oscillatingFollower.strokeWidth = OSCILLATING_FOLLOWER_WIDTH;
    oscillatingFollower.rotate(rotationAngle, oscillatingPivot);
    oscillatingFollower.bringToFront();

    /////// Find cam radius:
    oscillatingRadius = oscillatingFollower.segments[0].point.getDistance(origin);
    oscillatingPointBase = oscillatingFollower.segments[0].point.clone();
    oscillatingPointRotated = oscillatingPointBase.rotate(-totAngle, origin);
    if (camPath.segments.length === 0) {
      camPath.moveTo(oscillatingPointRotated);
    } else {
      camPath.add(oscillatingPointRotated);
    }
  }
}

/////////////////


	camStaticReference = camPath.clone(); // Reference cam for rotation, constant
	vector.x = 0;
	vector.y = 0;
	vector.angle = -70;
	drawReferenceRays(vector);
}



function drawReferenceRays(vect) {
	vect.length = CAM_RADIUS;
	// Draw reference "rays" (one per segment):
	for (var index = 0 ; index < flatPath.segments.length; index++) {
		vect.angle = flatPath.segments[index].point.x + ANGLE_OFFSET + GRID_X_OFFSET;
		relativePoint = origin + vect;
		if (radii[index]) {
			radii[index].remove();
		}
		radii.push(new Path(origin, relativePoint));
		radiiReference.push(new Path(origin, relativePoint));
		radii[index].strokeColor = "#FF0000";

		vertLine = new Path(new Point(flatPath.segments[index].point.x ,0 + GRID_Y_OFFSET), new Point(flatPath.segments[index].point.x ,CAM_RADIUS + GRID_X_OFFSET));
		if (verticalLines[index]) {
			verticalLines[index].remove();
		}
		verticalLines.push(vertLine);
		verticalLines[index].strokeColor = "#FF0000";
		verticalLines[index].bringToFront();
	}
}


function exportSVG() {
	allowRotation = false;
	resetRotation();
	camPath.setStrokeColor(camPath.getFillColor());

	SVGheader = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 300">\
	<g fill="#AAA" stroke="#000000" stroke-width="1">';

	SVGfooter = '	</g>\
	</svg>';

	SVGtext = camPath.exportSVG(	 { asString: true}	 );

	// Before exporting, create a copy of cam and reposition it so as to touch top/left borders:
	copy = camPath.clone();

	// Define new center for cam
	X_MARGIN = 10;
	Y_MARGIN = 10;
	newCenterX = camPath.bounds.width/2 + X_MARGIN;
	newCenterY = camPath.bounds.height/2 + Y_MARGIN;

	// Move copy to new position
	copy.position = new Point(newCenterX, newCenterY );

	centerDot = new Path.Circle({
				center: new Point(newCenterX, newCenterY),
				radius: '1',
				strokeColor: '#FFFFFF',
				strokeWidth : '1',
				fillColor: '#FFFFFF'
		})
	// Create SVG export string
	SVGtext = SVGheader + copy.exportSVG(	 { asString: true}	 ) +
	//centerHole.exportSVG(	 { asString: true}	 ) +
	centerDot.exportSVG(	 { asString: true}	 ) +
	SVGfooter;

	// Ask user to download the SVG version of the cam:
	fileName = "cam.svg"; // Default suggested name
	var url = "data:image/svg+xml;utf8," + encodeURIComponent(SVGtext); // Convert SVG string into downloadable format
	copy.remove(); // Remove clone of the cam

	// Prompt user for downloading:
	var link = document.createElement("a");
	link.download = fileName;
	link.href = url;
	link.click();

	camPath.setStrokeColor("#000000");
}

</script>
</head>

<body>
<center><big><big>Javascript Cam/Follower mechanism generator/simulator</big></big><br>
v. 0.3.0 - 26/10/2023<br>
Made with <a href="http://paperjs.org/tutorials/">paper.js</a> by Jumpjack<br>
Source code: <a href="https://github.com/jumpjack/CamFollowerJS">link</a><br>

<table border=1>
<tr><td colspan=2><center>File loaded:<span id="filename" name="filename">none</span></center></td></tr>
<tr>
	<td style="vertical-align:top;" width = 100>
		Flat profile (JSON format):<br>
		<input type='file' id='fileinput' name='fileinput' accept=".json" style="display:none;">
		<input type="button" id="btnLoadJSON" name="btnLoadJSON" value="Load" onclick="document.getElementById('fileinput').click();" />
		<button id="btnSave" name="btnSave">Save</button><br>
		<br>
		Circular profile (SVG format):<br>
		<input type='file' id='SVGfileinput' name='SVGfileinput'	accept=".svg" style="display:none;">
		<input type="button" id="btnLoadSVG" name="btnLoadSVG" value="Load" onclick="document.getElementById('SVGfileinput').click();" />
		<button id="btnExportSVG" name="btnExportSVG">Save</button><br>
		<br>
		Raster to SVG online converter:<a href="https://image.online-convert.com/convert-to-svg">link</a><br>
		<br>
		<br>
	Rotation: <button id="btnStart" name="btnStart">Start</button><button id="btnStop" name="btnStop">Stop</button>	<button id="btnReset" name="btnStop">Reset</button><br>
	<br>
	Please use one of these services<br>
	to convert SVG file to STL format<br>
	 for 3d printing:<br>
	<a href="https://rawgit.com/ryancalme/svg-to-stl/master/SVGtoSTL.html">Link 1</a><br>
	<a href="http://svg2stl.com/">Link 2</a><br>
<br><br>
	Status: <span id="spnStatus" name="spnStatus">-</span><br>
	Objects count: <span id="spnCount" name="spnCount">-</span><br>
	<br>

	</td>

	<td>
	<canvas id="myCanvas" width=750 height=700 style="background:#EEEEEE;"></canvas><br>
	<center>
	Polar zoom: <input type="range" id="rngZoom" name="rngZoom" value = "0" min= "1" max = "5" step="0.1" ><br>
	Cartesian offset: <input type="range" id="rngOffset" name="rngOffset" value = "0" min= "1" max = "100" step="1" ><br>
	Follower offset: <input type="range" id="rngFollowerOffset" name="rngFollowerOffset" value = "0" min= "-100" max = "100">
	<button id="btnFollowerReset" name="btnFollowerReset">Reset</button>
	<button id="btnRecalcPressure" name="btnRecalcPressure">Recalc pressure</button>
	<br>
	<button id="btnGrid" name="btnGrid">Grid back/front</button>
	<button id="btnShow" name="btnShow">Points</button><br>
	Rotation angle: <span id="lblAngle" name="lblAngle">0</span><span class="slidecontainer">
		<input type="range" min="0" max="359" value="5" class="slider" id="rngRotation" name="rngRotation">
	</span>
	<br>
	Pressure angle: <span id="spnPressure" name="spnPressure" style="color:#000000;">0</span>
	Realtime curve recalc: <input type="checkbox" id="chkPressReal" name="chkPressReal"><br>
	<br>
	</center>
	</td>

</tr>
<tr>
	<td colspan = 2>
		JSON imported data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<input type='button' id='btnReload' name='btnReload' value='Reload' >
		<input type='button' id='btnSmooth' name='btnSmooth' value='Smooth'>
		<br>
		<textarea id="fileContents" name="fileContents" cols=50 rows=30>
		</textarea><br>

		SVG imported data:<br>
		<textarea id="fileContentsSVG" name="fileContentsSVG" cols=50 rows=30>
		</textarea><br>
		<textarea id="tempcam" name="tempcam" cols=50 rows=30>
		</textarea><br>
	</td>
	<td style="vertical-align:top;">
	</td>
</tr>

</table>
</body>
</html>
